<html>

<body>
    <script>

        class UniqueSetOLD {
            constructor(...args) {
                this.pvt_strings = {};
                this.pvt_numbers = {};
                this.pvt_dates = {};

                Object.keys(args).forEach(i => {
                    this.push(args[i]);
                });
            }

            getDuplicates(...args) {
                const duplicates = new UniqueSet();
                const input = toString.call(args[0]) === '[object Array]' ? args[0] : args;
                const testSet = new UniqueSet();
                input.forEach(v => {
                    if (!testSet.has(v)) {
                        testSet.push(v);
                    } else {
                        duplicates.push(v);
                    }
                });
                return duplicates;
            }

            testUnique(...args) {
                let result;
                if (toString.call(args[0]) === '[object Array]') {
                    result = this.getDuplicates(args[0]).length === 0;
                } else {
                    result = this.getDuplicates(args).length === 0;
                }
                return result;
            }

            has(input) {
                const type = toString.call(input);
                let result = false;
                switch (type) {
                    case '[object Number]':
                        result = this.pvt_numbers.hasOwnProperty(input) ? true : false;
                        break;
                    case '[object String]':
                        result = this.pvt_strings.hasOwnProperty(input) ? true : false;
                        break;
                    case '[object Date]':
                        result = this.pvt_dates.hasOwnProperty(input) ? true : false;
                        break;
                }
                return result;
            }

            push(input) {
                const inputType = toString.call(input);
                (inputType === '[object Array]' ? input : [input]).forEach((i, index) => {
                    switch (toString.call(i)) {
                        case '[object Number]':
                            this.pvt_numbers[i] = Number;
                            break;
                        case '[object String]':
                            this.pvt_strings[i] = String;
                            break;
                        case '[object Date]':
                            this.pvt_dates[i] = Date;
                            break;
                        default:
                            throw new TypeError(
                                `UniqueSet can only store strings, numbers, dates. Received ${inputType} at index ${index}`
                            );
                    }
                });
                return this;
            }

            remove(input) {
                const inputType = toString.call(input);
                (inputType === '[object Array]' ? input : [input]).forEach((i, index) => {
                    switch (toString.call(i)) {
                        case '[object Number]':
                            delete this.pvt_numbers[i];
                            break;
                        case '[object String]':
                            delete this.pvt_strings[i];
                            break;
                        case '[object Date]':
                            delete this.pvt_dates[i];
                            break;
                        default:
                            throw new TypeError(
                                `UniqueSet can only store strings, numbers, dates. Received ${inputType} at index ${index}`
                            );
                    }
                });
                return this;
            }

            flush() {
                this.pvt_strings = {};
                this.pvt_numbers = {};
                this.pvt_dates = {};
                return this;
            }

            forEach(callback) {
                return this.values.forEach(callback);
            }

            copyItems(uniqueSet) {
                if (!(uniqueSet instanceof UniqueSet)) {
                    throw new TypeError('copyIndices accepts only UniqueSet input.');
                }
                return this.flush().push(uniqueSet.values);
            }

            get values() {
                return []
                    .concat(
                        Object.keys(this.pvt_numbers).map(i => {
                            return this.pvt_numbers[i](i);
                        })
                    )
                    .concat(
                        Object.keys(this.pvt_strings).map(i => {
                            return this.pvt_strings[i](i);
                        })
                    )
                    .concat(
                        Object.keys(this.pvt_dates).map(i => {
                            return this.pvt_dates[i](i);
                        })
                    );
            }

            get contains() {
                return {
                    numbers: Object.keys(this.pvt_numbers).length,
                    strings: Object.keys(this.pvt_strings).length,
                    dates: Object.keys(this.pvt_dates).length
                };
            }

            get holds() {
                const returnArray = [];
                const { numbers, strings, dates } = this.contains;
                if (numbers > 0) {
                    returnArray.push('numbers');
                }
                if (strings > 0) {
                    returnArray.push('strings');
                }
                if (dates > 0) {
                    returnArray.push('dates');
                }
                return returnArray;
            }

            get pure() {
                return this.holds.length < 2;
            }

            get isEmpty() {
                return this.values.length === 0;
            }

            get length() {
                return this.values.length;
            }
        }

        class UniqueSet {
            constructor(...args) {
                Object.defineProperties(this, {
                    pvt_strings: {
                        enumerable: false,
                        value: {}
                    },
                    pvt_numbers: {
                        enumerable: false,
                        value: {}
                    },
                    pvt_dates: {
                        enumerable: false,
                        value: {}
                    },
                    pvt_values: {
                        enumerable: false,
                        value: []
                    }
                });
                Object.keys(args).forEach(i => {
                    this.push(args[i]);
                });
            }

            getDuplicates(...args) {
                const duplicates = new UniqueSet();
                const input = toString.call(args[0]) === '[object Array]' ? args[0] : args;
                const testSet = new UniqueSet();
                input.forEach(v => {
                    if (!testSet.has(v)) {
                        testSet.push(v);
                    } else {
                        duplicates.push(v);
                    }
                });
                return duplicates;
            }

            testUnique(...args) {
                let result;
                if (toString.call(args[0]) === '[object Array]') {
                    result = this.getDuplicates(args[0]).length === 0;
                } else {
                    result = this.getDuplicates(args).length === 0;
                }
                return result;
            }

            has(input) {
                const type = toString.call(input);
                let result = false;
                switch (type) {
                    case '[object Number]':
                        result = this.pvt_numbers.hasOwnProperty(input) ? true : false;
                        break;
                    case '[object String]':
                        result = this.pvt_strings.hasOwnProperty(input) ? true : false;
                        break;
                    case '[object Date]':
                        result = this.pvt_dates.hasOwnProperty(input) ? true : false;
                        break;
                }
                return result;
            }

            push(input) {
                const inputType = toString.call(input);
                (inputType === '[object Array]' ? input : [input]).forEach((i, index) => {
                    if (!this.has(i)) {
                        this.pvt_values.push(i);
                    }
                    switch (toString.call(i)) {
                        case '[object Number]':
                            this.pvt_numbers[i] = true;
                            break;
                        case '[object String]':
                            this.pvt_strings[i] = true;
                            break;
                        case '[object Date]':
                            this.pvt_dates[i] = true;
                            break;
                        default:
                            throw new TypeError(
                                `UniqueSet can only store strings, numbers, dates. Received ${inputType} at index ${index}`
                            );
                    }
                });
                return this;
            }

            remove(...items) {
                const inputType = toString.call(items[0]);
                (inputType === '[object Array]' ? items[0] : items).forEach((i, index) => {
                    const indexOf = this.pvt_values.indexOf(i);
                    if (indexOf !== -1) {
                        this.pvt_values.splice(indexOf, 1);
                        switch (toString.call(i)) {
                            case '[object Number]':
                                delete this.pvt_numbers[i];
                                break;
                            case '[object String]':
                                delete this.pvt_strings[i];
                                break;
                            case '[object Date]':
                                delete this.pvt_dates[i];
                                break;
                            default:
                                throw new TypeError(
                                    `UniqueSet can only store strings, numbers, dates. Received ${inputType} at index ${index}`
                                );
                        }
                    }
                });
                return this;
            }

            flush() {
                this.pvt_strings = {};
                this.pvt_numbers = {};
                this.pvt_dates = {};
                this.pvt_values = [];
                return this;
            }

            forEach(callback) {
                return this.pvt_values.forEach(callback);
            }

            copyItems(uniqueSet) {
                if (!(uniqueSet instanceof UniqueSet)) {
                    throw new TypeError('copyIndices accepts only UniqueSet input.');
                }
                return this.flush().push(uniqueSet.values);
            }

            get values() {
                return this.pvt_values;
            }

            get counts() {
                return {
                    numbers: Object.keys(this.pvt_numbers).length,
                    strings: Object.keys(this.pvt_strings).length,
                    dates: Object.keys(this.pvt_dates).length
                };
            }

            get holds() {
                const returnArray = [];
                const { numbers, strings, dates } = this.counts;
                if (numbers > 0) {
                    returnArray.push('numbers');
                }
                if (strings > 0) {
                    returnArray.push('strings');
                }
                if (dates > 0) {
                    returnArray.push('dates');
                }
                return returnArray;
            }

            get pure() {
                return this.holds.length < 2;
            }

            get isEmpty() {
                return this.values.length === 0;
            }

            get length() {
                return this.values.length;
            }
        }



        function makeid(length, asInt) {
            var result = '';
            var characters;
            if (asInt) {
                characters = '0123456789';
            } else {
                characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            }
            var charactersLength = characters.length;
            for (var i = 0; i < length; i++) {
                result += characters.charAt(Math.floor(Math.random() * charactersLength));
            }
            if (asInt) {
                result = Number(result);
            }
            return result;
        }

        const data = [];
        const count = 1000;
        const iterations = 3;
        for (let i = 0; i < count; i++) {
            let rdm = Math.random();
            if (rdm > 0 && rdm < 0.334) {
                data.push(makeid(10, true));
            } else if (rdm >= 0.334 && rdm < 0.667) {
                data.push(makeid(10));
            } else {
                data.push(new Date());
            }
        }

        /*      
                console.log('UniqueSet starting');
                const rejected = [];
                for(let i =0; i< iterations; i++){
                    data.forEach(v =>{
                        if(v1.has(v)) {
                            rejected.push(v);
                        }else{
                            v1.push(v);
                        }
                    });
                }
                
                console.log(v1);
                console.log('these were rejected');
                console.log(rejected);
        */

        const startTime1 = Date.now();
        const v1 = new UniqueSet(data);
        for(var i=0; i<iterations; i++){
            data.forEach(v => {
                v1.push(v);
            });
        }
        console.log(Date.now() - startTime1);

        let v2 = [];
        const startTime2 = Date.now();
        for(var i=0; i<iterations; i++){
            data.forEach(v => {
                if (v2.indexOf(v) === -1) {
                    v2.push(v);
                }
            });
        }

        console.log(Date.now() - startTime2);

        const startTime3 = Date.now();
        const v3 = new UniqueSetOLD(data);
        for(var i=0; i<iterations; i++){
            data.forEach(v => {
                v3.push(v);
            });
        }
        console.log(Date.now() - startTime3);
    </script>
</body>

</html>